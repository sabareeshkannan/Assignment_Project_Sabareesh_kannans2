# Ideas & Selection Rationale

Assignment Project
- Idea 1: MealPrepped — Weekly meal planner, shopping list, expiry reminders, overall spending and current inventory dashboard, and a small "what to cook next" recommender.
- Idea 2: Health and Fitness Tracker — Track workouts, set goals, monitor progress.

Chosen: MealPrepped  
Reason: It solves a real pain point for me and is easy to test in daily life. The app naturally supports CRUD operations, dashboards, and a small ML recommender feature, which I find technically interesting as well.


# Wireframe notes
I have designed a rough sketch of the main pages of the website.

1) Dashboard
The website's main page would be the dashboard, which will serve as a glance of the meal prep progress for the week. 
This is also a navigation bar at the top, so that it would be easy to jump between sections. 


2) Weekly Plan 
There are sections for lunch and dinner for each day, as breakfast would usually not require a plan.
You are able to easily add meal or generate a new shopping list if necessary, especially if the previous dashboard says that you are running out of certain items that you have planned to make in the subsequent days. 
There is also a section for notes, just in case there are leftovers.


3) Recipes List
Card layout makes scanning quick, and easy for the user to click and expand for the full recipe. 
Search and simple filters live above the grid to easily find a favourite recipe. (add an additional filter for this)


4) Inventory
A straightforward table (name, qty, unit, expiry).
“Expiring soon” and “Low stock” are broken out on the side to bring attention to the user.
Sorting by Expiry/Qty supports the two most common decisions: use it now or restock.


# Branch Usage Reflections 

I made a wf/v1 branch just for my wireframes so they would not mix with the rest of the project. It was easier to keep things organised this way, and then I merged it back into main once I was done.


# Branching Strategy

I kept the branching plan very simple so I can build one feature at a time and not break main.


1) models
   - Start with the data models and Django admin because everything else depends on them.

2) planner
The weekly planner is the core of the app, so I want to get that working next.
A basic 7-day grid with lunch/dinner slots will let me connect recipes later.

3) recipes-list
After the planner is ready, I will add the recipe list with search and filters.
This supports the planner because I can add recipes directly to the plan.

4) inventory/shopping list
Then I will build the inventory page with quantities and expiry dates.
This gives me the data needed for reminders and for the dashboard.

5) dashboard
I will add the dashboard that pulls info from the other three features.
I left this last since it depends on planner, recipes, and inventory.

6) ml-recommender
Finally I will add a machine learning recommender later to suggest “what to cook next.”

Doing it in this order helps me build from the basics (data) up to the overview (dashboard).
Each feature gets its own branch so I would not mess up main while I am still working.
Once a feature is ready, I will merge it into main and move on to the next one.


# Django Setup

startproject folder_name: main
I chose “main” so it is simple and clearly shows this is the main project folder with all the settings and configuration.

app_name: mealprepped
I chose “mealprepped” because the app is about planning meals, managing recipes, and keeping track of inventory. The name matches the goal of the project and makes it obvious what the app does.



# Virtual Environment Choices

I used Python venv inside my project folder (.venv).  
Keeping the virtual environment in the same folder makes it easy to find and connect in PyCharm.  
It also keeps all the project packages separate from my global Python so no error occurs as a result of this.


# Extra Credit

In a team, git stash is like putting your half-done work into a safe drawer so you can help with something else. If your teammate asks you to fix a bug on main, you run git stash command switch to main, pull, make the fix, commit and push. Then you are able to switch back to your branch and bring your saved work back. This keeps unfinished code out of the shared history and lets you switch tasks without losing anything. 


# Modelling notes

1) Why these models/fields?
Ingredient: Simple catalog of things you cook with, which stores the name and a unit (g/ml/pcs). 
Recipe: Overall dish overview with title, optional description, servings, and prep/cook minutes.
RecipeIngredient: This contains the quantity per ingredient per recipe. line-item “payload” table (quantity per ingredient per recipe). This allows me to model many-many data.
MealPlan: A date range (usually should be a week) that groups entries. This would allow me to add additional features such as a dashboard for budgeting and provide a weekly view of it. 
MealPlanEntry: One slot for different periods of the day (breakfast/lunch/dinner/snack). The slot will usually refer a recipe, but would still hold if that particular recipe is deleted. 

2) Relationship choices
RecipeIngredient.recipe - ForeignKey(CASCADE): Deleting a recipe should delete its items.
RecipeIngredient.ingredient - ForeignKey(PROTECT): Deleting would be blocked if any recipes use it.
MealPlanEntry.meal_plan - ForeignKey(CASCADE): Removing a plan removes its entries.
MealPlanEntry.recipe  ForeignKey(SET_NULL): Keep the slot if a recipe goes away (slot becomes “TBD”).

3) Constraints 
- Uniqueness:
  - RecipeIngredient: Unique (recipe, ingredient) — No duplicate ingredient rows in a recipe.
  - MealPlanEntry: Unique (meal_plan, date, meal_type) — No double-booking the same slot.
  
- Ordering:
	- Ingredient -> name (Potentially to be changed to be ordered by quantity)
	- Recipe -> Title
	- RecipeIngredient -> Recipe then ingredient
	- MealPlan -> By earliest start date first, then name
	- MealPlanEntry -> Date, meal_type
  

4) How did I seed the test data?
Initially, I manually added the entries through the admin portal. However, I discovered that creating entries through the shell terminal was faster. 
I used the shell terminal to create 3 receipes to cover the periods of the day, each with 2 to 4 ingredients (8 total ingredients).
Additionally, I created a MealPlan for the current week, with a few MealPlanEntry rows.
  
  
5) Checklist for A3: 
1. Define models with fields, PKs, FKs (+ on_delete choices).
2. Add at least one UniqueConstraint and Meta.ordering.
3. makemigrations → migrate.
4. Register models in admin.py; createsuperuser.
5. Add test data via Admin / shell.
6. Verify FK behavior (try deleting a parent to see PROTECT/CASCADE).
7. Commit + push after each milestone (models, migrations, admin, data). 
8. Update README + docs/notes/notes.txt. 
9. Upload db.sqlite3 on Canvas.

# MVT Notes (A4) 
I implemented two view styles to compare HttpResponse with render(). 
Doing them on separate pages (Ingredients vs. Recipes) makes the contrast clearer while keeping the same flow
From my experience, I felt that the render() function does the "heavy lifting", by loading the template, merging the context and returning a response all in one line, making it harder to make mistakes on. 

Difference between HttpResponse and render(): 
HttpResponse is typically used to send back simple content such as plain text, as it allows you to define the string that is displayed as the content.
render() is a more convenient way of handling the loading of the template and merging the data in one step, returning a response with the HTML already rendered. 

URL/template decisions: I used separate routes for each —/ingredients-list/, /recipes-list/, /plan/week/—and a base.html layout with {% block title %}/{% block content %}.
I decided to create an additional a subroute for the weekly meal plan (stored in the plan folder by weeks) , as it would be easier to navigate to each seperate meal plan by week, just by altering the date. I plan to implement this in the future. 
The recipes template includes a {% empty %} block to handle and indicate to the user that there are no recipe records.

#Class-based views notes (A5)
Base CBVs vs Generic CBVs
Base CBVs inherit from View. I implement get(), query the model explicitly, and call render() with a context I build. This gives me full control but more boilerplate.
Generic CBVs (ListView, DetailView) provide standard behaviour out of the box. I set attributes like model=Recipe, context_object_name="recipes", and optionally template_name. Django is able to handle the rest.

Why generic views reduce boilerplate
They are able to handle common patterns out of the box, making them easy to use, as there are fewer lines of code to maintain.

Why refactoring URLs helps maintainability
Keeping app routes in mealprepped/urls.py and including them once in the project urls.py keeps the project root clean and modular. It also prevents name clashes between apps.

# Filtering & Aggregation (A6)
Filtering vs. aggregation: Filtering identifies the records which matches the search, while aggregation summarises the data across the selected rows, for example by finding the total of a certain grouped count.
Search flow: read `q = request.GET.get("q")`, filter `Recipe` with `Q(title__icontains=q) | Q(description__icontains=q)`, keep full list (`recipes`) separate from `search_results` in `get_context_data` 
The template uses `{% empty %}` in the search results loop to show “No recipes matched…” when `search_results` is empty.
Aggregation list: 
Total: `Recipe.objects.count()` -> displays “Total recipes”.
Most-used recipes in meal plans are also computed and linked to each recipe's detail page.
Recipes by ingredient count, ranking dishes by number of ingredients (simple to complex).
