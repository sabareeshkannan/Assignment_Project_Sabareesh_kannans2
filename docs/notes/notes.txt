# Ideas & Selection Rationale

Assignment Project
- Idea 1: MealPrepped — Weekly meal planner, shopping list, expiry reminders, overall spending and current inventory dashboard, and a small "what to cook next" recommender.
- Idea 2: Health and Fitness Tracker — Track workouts, set goals, monitor progress.

Chosen: MealPrepped  
Reason: It solves a real pain point for me and is easy to test in daily life. The app naturally supports CRUD operations, dashboards, and a small ML recommender feature, which I find technically interesting as well.


# Wireframe notes
I have designed a rough sketch of the main pages of the website.

1) Dashboard
The website's main page would be the dashboard, which will serve as a glance of the meal prep progress for the week. 
This is also a navigation bar at the top, so that it would be easy to jump between sections. 


2) Weekly Plan 
There are sections for lunch and dinner for each day, as breakfast would usually not require a plan.
You are able to easily add meal or generate a new shopping list if necessary, especially if the previous dashboard says that you are running out of certain items that you have planned to make in the subsequent days. 
There is also a section for notes, just in case there are leftovers.


3) Recipes List
Card layout makes scanning quick, and easy for the user to click and expand for the full recipe. 
Search and simple filters live above the grid to easily find a favourite recipe. (add an additional filter for this)


4) Inventory
A straightforward table (name, qty, unit, expiry).
“Expiring soon” and “Low stock” are broken out on the side to bring attention to the user.
Sorting by Expiry/Qty supports the two most common decisions: use it now or restock.


# Branch Usage Reflections 

I made a wf/v1 branch just for my wireframes so they would not mix with the rest of the project. It was easier to keep things organised this way, and then I merged it back into main once I was done.


# Branching Strategy

I kept the branching plan very simple so I can build one feature at a time and not break main.


1) models
   - Start with the data models and Django admin because everything else depends on them.

2) planner
The weekly planner is the core of the app, so I want to get that working next.
A basic 7-day grid with lunch/dinner slots will let me connect recipes later.

3) recipes-list
After the planner is ready, I will add the recipe list with search and filters.
This supports the planner because I can add recipes directly to the plan.

4) inventory/shopping list
Then I will build the inventory page with quantities and expiry dates.
This gives me the data needed for reminders and for the dashboard.

5) dashboard
I will add the dashboard that pulls info from the other three features.
I left this last since it depends on planner, recipes, and inventory.

6) ml-recommender
Finally I will add a machine learning recommender later to suggest “what to cook next.”

Doing it in this order helps me build from the basics (data) up to the overview (dashboard).
Each feature gets its own branch so I would not mess up main while I am still working.
Once a feature is ready, I will merge it into main and move on to the next one.


# Django Setup

startproject folder_name: main
I chose “main” so it is simple and clearly shows this is the main project folder with all the settings and configuration.

app_name: mealprepped
I chose “mealprepped” because the app is about planning meals, managing recipes, and keeping track of inventory. The name matches the goal of the project and makes it obvious what the app does.



# Virtual Environment Choices

I used Python venv inside my project folder (.venv).  
Keeping the virtual environment in the same folder makes it easy to find and connect in PyCharm.  
It also keeps all the project packages separate from my global Python so no error occurs as a result of this.


# Extra Credit

In a team, git stash is like putting your half-done work into a safe drawer so you can help with something else. If your teammate asks you to fix a bug on main, you run git stash command switch to main, pull, make the fix, commit and push. Then you are able to switch back to your branch and bring your saved work back. This keeps unfinished code out of the shared history and lets you switch tasks without losing anything. 


# Modelling notes

1) Why these models/fields?
Ingredient: Simple catalog of things you cook with, which stores the name and a unit (g/ml/pcs). 
Recipe: Overall dish overview with title, optional description, servings, and prep/cook minutes.
RecipeIngredient: This contains the quantity per ingredient per recipe. line-item “payload” table (quantity per ingredient per recipe). This allows me to model many-many data.
MealPlan: A date range (usually should be a week) that groups entries. This would allow me to add additional features such as a dashboard for budgeting and provide a weekly view of it. 
MealPlanEntry: One slot for different periods of the day (breakfast/lunch/dinner/snack). The slot will usually refer a recipe, but would still hold if that particular recipe is deleted. 

2) Relationship choices
RecipeIngredient.recipe - ForeignKey(CASCADE): Deleting a recipe should delete its items.
RecipeIngredient.ingredient - ForeignKey(PROTECT): Deleting would be blocked if any recipes use it.
MealPlanEntry.meal_plan - ForeignKey(CASCADE): Removing a plan removes its entries.
MealPlanEntry.recipe  ForeignKey(SET_NULL): Keep the slot if a recipe goes away (slot becomes “TBD”).

3) Constraints 
- Uniqueness:
  - RecipeIngredient: Unique (recipe, ingredient) — No duplicate ingredient rows in a recipe.
  - MealPlanEntry: Unique (meal_plan, date, meal_type) — No double-booking the same slot.
  
- Ordering:
	- Ingredient -> name (Potentially to be changed to be ordered by quantity)
	- Recipe -> Title
	- RecipeIngredient -> Recipe then ingredient
	- MealPlan -> By earliest start date first, then name
	- MealPlanEntry -> Date, meal_type
  

4) How did I seed the test data?
Initially, I manually added the entries through the admin portal. However, I discovered that creating entries through the shell terminal was faster. 
I used the shell terminal to create 3 receipes to cover the periods of the day, each with 2 to 4 ingredients (8 total ingredients).
Additionally, I created a MealPlan for the current week, with a few MealPlanEntry rows.
  
  
5) Checklist for A3: 
1. Define models with fields, PKs, FKs (+ on_delete choices).
2. Add at least one UniqueConstraint and Meta.ordering.
3. makemigrations → migrate.
4. Register models in admin.py; createsuperuser.
5. Add test data via Admin / shell.
6. Verify FK behavior (try deleting a parent to see PROTECT/CASCADE).
7. Commit + push after each milestone (models, migrations, admin, data). 
8. Update README + docs/notes/notes.txt. 
9. Upload db.sqlite3 on Canvas.

# MVT Notes (A4) 
I implemented two view styles to compare HttpResponse with render(). 
Doing them on separate pages (Ingredients vs. Recipes) makes the contrast clearer while keeping the same flow
From my experience, I felt that the render() function does the "heavy lifting", by loading the template, merging the context and returning a response all in one line, making it harder to make mistakes on. 

Difference between HttpResponse and render(): 
HttpResponse is typically used to send back simple content such as plain text, as it allows you to define the string that is displayed as the content.
render() is a more convenient way of handling the loading of the template and merging the data in one step, returning a response with the HTML already rendered. 

URL/template decisions: I used separate routes for each —/ingredients-list/, /recipes-list/, /plan/week/—and a base.html layout with {% block title %}/{% block content %}.
I decided to create an additional a subroute for the weekly meal plan (stored in the plan folder by weeks) , as it would be easier to navigate to each seperate meal plan by week, just by altering the date. I plan to implement this in the future. 
The recipes template includes a {% empty %} block to handle and indicate to the user that there are no recipe records.

#Class-based views notes (A5)
Base CBVs vs Generic CBVs
Base CBVs inherit from View. I implement get(), query the model explicitly, and call render() with a context I build. This gives me full control but more boilerplate.
Generic CBVs (ListView, DetailView) provide standard behaviour out of the box. I set attributes like model=Recipe, context_object_name="recipes", and optionally template_name. Django is able to handle the rest.

Why generic views reduce boilerplate
They are able to handle common patterns out of the box, making them easy to use, as there are fewer lines of code to maintain.

Why refactoring URLs helps maintainability
Keeping app routes in mealprepped/urls.py and including them once in the project urls.py keeps the project root clean and modular. It also prevents name clashes between apps.

# Filtering & Aggregation (A6)
Filtering vs. aggregation: Filtering identifies the records which matches the search, while aggregation summarises the data across the selected rows, for example by finding the total of a certain grouped count.

Search flow: read `q = request.GET.get("q")`, filter `Recipe` with `Q(title__icontains=q) | Q(description__icontains=q)`, keep full list (`recipes`) separate from `search_results` in `get_context_data` 

The template uses `{% empty %}` in the search results loop to show “No recipes matched…” when `search_results` is empty.

Aggregation list: 
Total: `Recipe.objects.count()` -> displays “Total recipes”.
Most-used recipes in meal plans are also computed and linked to each recipe's detail page.
Recipes by ingredient count, ranking dishes by number of ingredients (simple to complex).

# Static files + Chart (A7)
How do static files work? I placed CSS under app_name/static/app_name/css and linked them in base.html with {% load static %} and <link rel="stylesheet" href="{% static '...' %}">. STATIC_URL/STATICFILES_DIRS let Django find these assets in development.

What does my chart show? A simple bar chart of recipe counts by total time (prep + cook), using four fixed intervals up to 60 minutes (≤15, 16–30, 31–45, 46–60). This gives a quick sense of how long most recipes would take to cook.

What ORM aggregation was used? I annotatd each recipe with total = prep_minutes + cook_minutes, then use Count with the filter method to compute how many recipes fall in each time interval.

BytesIO: It helps to save Matplotlib plot png file to BytesIO (as PNG) and returns it in an HttpResponse without writing any files to diskm and therefore not taking up space in your local disk.
tight_layout(): It is a helper method that adjusts margins so titles, axes, and labels are not misaligned

# Forms, GET vs POST, and Function-Based vs Class-Based Views  (A8)
CSRF: A token inserted into POST forms to prevent requests from unauthorised sources. Django verifies it on submit.

Form submission flow: Render empty form (GET) → submit (POST) -> validate (form.is_valid()) -> If invalid re-render with errors, else if valid save or you are also able to redirect to another page.

GET vs POST: GET for safe, idempotent reads and replicable results by anybody with the link. POST for creates or updates that should stored in the backend, protected by CSRF.

FBV pros: Explicit control path, easy to customise multiple branches. 
Cons: More boilerplate code, and more cases where bugs can be made.
CBV pros: Less boilerplate code via due to presets like CreateView.
Cons: May be harder to understand the logic, due to a high level of abstraction and the majority of work being done by the preset template.

# APIs + JSON Endpoints + Chart Integration (A9)

What is a JSON API
A JSON API is an HTTP endpoint that returns machine-readable data in JSON format rather than HTML.
It has a stable structure, so clients know which keys to read. Example for this project: /api/mealplans/status/ returns totals and a results list with {"status": "...", "n": ...}.

HttpResponse vs JsonResponse
JsonResponse converts a Python dict to JSON and sets Content-Type: application/json automatically.
HttpResponse returns the bytes and you set the Content-Type yourself.
In this project the API uses JsonResponse. The chart view uses HttpResponse with image/png.

What the chart shows and how data flows from API to chart view
Chart: a pie showing Meal Plans that are completely filled versus unfilled. Completely filled means the plan has entries on all seven days within that week's window
  1) Server builds the absolute API URL with build_absolute_uri(reverse(...)).
  2) Server fetches JSON using urllib.request.urlopen and parses it with json.load.
  3) View extracts the counts for "complete" and "unfilled".
  4) Matplotlib renders a pie as PNG.
  5) View returns HttpResponse with content_type="image/png".
  6) Template embeds the PNG via the HTML file.


# External APIs (Open API / Non-Keyed) (A10)

API chosen: TheMealDB. Fits my Recipes feature and returns small JSON. Endpoint: https://www.themealdb.com/api/json/v1/1/search.php?s=<query>.
Fields extracted : idMeal, name (from strMeal), category (strCategory), area (strArea), thumb (strMealThumb). I keep only the first 9 results.
Errors and timeouts: requests.get(..., params={"s": q}, timeout=5) with resp.raise_for_status(). Wrapped in try/except for requests.exceptions.RequestException.
JSON mode returns {"ok": False, "error": "..."} with HTTP 502 and HTML shows an error message.
JSON shape:
{
  "ok": true,
  "query": "chicken",
  "count": 3,
  "results": [
    {"idMeal":"52795","name":"Chicken Handi","category":"Chicken","area":"Indian","thumb":"https://..."}
  ]
}
When there are no matches the API returns "meals": null rather than []. It is not necessary for all fields to be filled, some can be empty and they needed to be handled accordingly.

# CSV / JSON Export + Reports (A11.1)

- CSV generation: Uses HttpResponse + csv.writer and set Content-Disposition to a timestamped filename.
- JSON generation: A JsonResponse with the content and indent=2 is returned for pretty output.
- CSV columns: mealplan_id, name, start_date, end_date, n_entries, n_days.
- JSON fields include the above columns and also the variables for the time it was generated.
- Meal-plan list page summaries: Total meal plans and categories seperated by (complete, in progress, filled any, empty/no_range)


# Deployment notes (A12)

- Settings split
  - Single settings.py split into: main/settings/base.py, development.py, production.py.
  - base.py: shared config (apps, middleware, templates, DB, static).
  - dev/prod both: from .base import *.
  - Local: DJANGO_SETTINGS_MODULE=main.settings.development.
  - PythonAnywhere: DJANGO_SETTINGS_MODULE=main.settings.production (set in WSGI).

- Database (data/ folder)
  - BASE_DIR = Path(__file__).resolve().parent.parent → main/.
  - DB path: BASE_DIR / "data" / "db.sqlite3"
    → /home/kannans2/Assignment_Project_Sabareesh_kannans2/main/data/db.sqlite3 on PythonAnywhere.
    - python manage.py migrate --settings=main.settings.production

- Static files
  - STATIC_URL = "static/"
  - STATIC_ROOT = BASE_DIR / "staticfiles"
  - STATICFILES_DIRS = [BASE_DIR / "static"]
  - On PythonAnywhere:
    - STATIC_ROOT → /home/kannans2/Assignment_Project_Sabareesh_kannans2/main/staticfiles
    - Collect with: python manage.py collectstatic --settings=main.settings.production
    - Web tab mapping: /static/ → /home/kannans2/Assignment_Project_Sabareesh_kannans2/main/staticfiles


- WSGI (PythonAnywhere)
  - /var/www/kannans2_pythonanywhere_com_wsgi.py:
    - path = "/home/kannans2/Assignment_Project_Sabareesh_kannans2"
      if path not in sys.path: sys.path.append(path)
    - os.environ.setdefault("DJANGO_SETTINGS_MODULE", "main.settings.production")
    - application = get_wsgi_application()

- Deployment flow (local → GitHub → PythonAnywhere)
  1) Local: develop with main.settings.development, DB at main/data/db.sqlite3.
  2) git add ., git commit, git push.
  3) On PA: git clone into /home/kannans2/Assignment_Project_Sabareesh_kannans2.
  4) Create venv (myenv-django, Python 3.12); pip install -r main/requirements.txt.
  5) Migrate: python manage.py migrate --settings=main.settings.production
  6) Create superuser
  7) Collect static: python manage.py collectstatic --settings=main.settings.production
  8) Web tab: set virtualenv, static mapping, WSGI DJANGO_SETTINGS_MODULE.
  9) Reload and test:
     - https://kannans2.pythonanywhere.com/